<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>muimui XD chart broker</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script>
        let c, ctx;
        let data;
        let note = [];
        let startTime;
        let triggered = []
        let T = 0;
        let sfxs = {
            'guide': null
        }
        let settings = {
            'speed': 1,
            'paused': true,
            'disToMid': 0.3,
            'noteThickness': 0.375,
            'noteSize': 2,
            'offset': 0,
            'touchSpeed': 1
        }
        let noteImages = {
            'outline': null,

            'tap': null,
            'break': null,
            'each': null,
            'tap_ex': null,

            'hold': null,
            'hold_break': null,
            'hold_each': null,
        }
        let bgm;
        let timeLine;

        $(document).ready(function () {
            settings.speed = parseFloat($("#speed").val());
            sfxs.guide = $("#sfx-guide")[0];
            bgm = $("#audio");
            timeLine = $("#time");
            bgm.volume = 0.75;

            $("#viewMode").prop("checked", settings.paused);
            $("#time").prop("disabled", !settings.paused);

            $("#offset").on("input", function () {
                settings.offset = parseFloat($(this).val());
                if (isNaN(settings.offset)) {
                    settings.offset = 0;
                }
                if (!isNaN(bgm[0].duration)) {
                    bgm[0].currentTime = T / 1000 + settings.offset;
                }
            });

            $("#music").on("input", function () {
                let file = $(this)[0].files[0];
                let reader = new FileReader();
                reader.onload = function (e) {
                    bgm.attr('src', e.target.result);
                }
                reader.readAsDataURL(file);
                bgm[0].load();

                if (!settings.paused) {
                    bgm[0].currentTime = T / 1000 + settings.offset;
                    bgm[0].play();
                }
            });

            $("#editor")
                .html(example)
                .on("input", function () {
                    data = $(this).val().replace(/(\r\n|\n|\r)/gm, "");
                    try {
                        note = simai_decode(data);
                    } catch (error) {
                        console.log(error);
                    }
                    if (!isNaN(bgm[0].duration)) {
                        bgm[0].load();
                        bgm[0].currentTime = T / 1000 + settings.offset;
                    }
                    settings.paused = true;
                    $("#viewMode").prop("checked", settings.paused);
                    $("#time").prop("disabled", !settings.paused);
                    startTime = Date.now() - parseFloat($("#time").val());
                    if (!settings.paused) {
                        $("#time").val(0);
                    }
                });

            $("#speed").on("input", function () {
                settings.speed = parseFloat($(this).val());
            });

            $("#viewMode").on("input", function () {
                settings.paused = $(this).prop("checked");
                $("#time").prop("disabled", !settings.paused);
                if (!isNaN(bgm[0].duration)) {
                    settings.paused ? bgm[0].pause() : bgm[0].play();
                }
                startTime = Date.now() - parseFloat($("#time").val());
            });

            noteImages.outline = $("#outline")[0];
            noteImages.tap = $("#tap")[0];
            noteImages.break = $("#break")[0];
            noteImages.each = $("#each")[0];
            noteImages.tap_ex = $("#tap_ex")[0];

            noteImages.hold = $("#hold")[0];
            noteImages.hold_break = $("#hold_break")[0];
            noteImages.hold_each = $("#hold_each")[0];
            //noteImages.hold_ex = $("#hold_ex")[0];

            c = $("#render")[0];
            ctx = c.getContext("2d");
            data = $("#editor").val().replace(/(\r\n|\n|\r)/gm, "");
            try {
                note = simai_decode(data);
            } catch (error) {
                console.log(error);
            }
            requestAnimationFrame(render);
        });

        function simai_decode(data) {
            startTime = Date.now();
            let tempNote = [];
            triggered = []
            let dataTemp = data.split(",");
            let timeSum = 0;
            let slice = 1;
            let bpm = 60;

            for (let i = 0; i < dataTemp.length; i++) {
                let dat = dataTemp[i];

                if (dat) {
                    while (dat.includes("(") && dat.includes(")")) {
                        bpm = parseFloat(dat.slice(dat.indexOf("(") + 1, dat.indexOf(")")));
                        if (dat.lastIndexOf("(") < dat.indexOf(")")) {
                            dat = dat.slice(0, dat.slice(0, dat.indexOf(")")).lastIndexOf("(")) + dat.slice(dat.indexOf(")") + 1, dat.length);
                        } else {
                            break;
                        }
                    }
                    dataTemp[i] = dat;

                    while (dat.includes("{") && dat.includes("}")) {
                        slice = parseFloat(dat.slice(dat.lastIndexOf("{") + 1, dat.indexOf("}")));
                        dat = dat.slice(dat.indexOf("}") + 1, dat.length);
                    }
                    dataTemp[i] = dat;

                    if (dat.includes("/")) {
                        dat = dat.split("/");
                        for (let j = 0; j < dat.length; j++) {
                            if (dat[j] == "") {
                                continue;
                            }
                            tempNote.push({ 'pos': dat[j], 'time': timeSum, bpm });
                        }
                    }

                    if (dat.length > 1 && !isNaN(dat)) {
                        for (let j = 0; j < dat.length; j++) {
                            tempNote.push({ 'pos': dat[j], 'time': timeSum, bpm });
                        }
                    }
                    dat = dataTemp[i];
                }

                if (!(dat.includes("/")) && dat) { tempNote.push({ 'pos': dataTemp[i], 'time': timeSum, bpm }); }
                timeSum += (1 / slice) * (60 / bpm) * 4000;
            }

            for (let i = 0; i < tempNote.length; i++) {
                let dat = tempNote[i];

                if (dat.pos.indexOf("h") != -1 && dat.pos.includes("[") && dat.pos.includes("]")) {
                    let temp = dat.pos.split("[");
                    temp[1] = temp[1].slice(0, temp[1].indexOf("]"));
                    temp[1] = temp[1].split(":");
                    temp[1][0] = parseFloat(temp[1][0]);
                    temp[1][1] = parseFloat(temp[1][1]);
                    temp[1] = temp[1][1] / temp[1][0];
                    temp[1] == Infinity ? temp[1] = 0 : null;
                    temp[0] = temp[0].split("h");
                    temp[0] = temp[0][0];
                    tempNote[i] = ({ 'pos': temp[0], 'time': dat.time, 'holdTime': temp[1] * (60 / dat.bpm) * 4 });
                    dat = tempNote[i];
                }

                if (dat.pos.includes("b")) {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("b")) + dat.pos.slice(dat.pos.indexOf("b") + 1, dat.pos.length);
                    tempNote[i].break = true;
                }

                if (dat.pos.includes("x")) {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("x")) + dat.pos.slice(dat.pos.indexOf("x") + 1, dat.pos.length);
                    tempNote[i].ex = true;
                }

                if (dat.pos.includes("f")) {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("f")) + dat.pos.slice(dat.pos.indexOf("f") + 1, dat.pos.length);
                    tempNote[i].hibana = true;
                }

                if (dat.pos[0] == 'A') {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("A")) + dat.pos.slice(dat.pos.indexOf("A") + 1, dat.pos.length);
                    tempNote[i].touch = 'A';
                }

                if (dat.pos[0] == 'B') {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("B")) + dat.pos.slice(dat.pos.indexOf("B") + 1, dat.pos.length);
                    tempNote[i].touch = 'B';
                }

                if (dat.pos[0] == 'C') {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("C")) + dat.pos.slice(dat.pos.indexOf("C") + 1, dat.pos.length);
                    if (tempNote[i].pos == '') {
                        tempNote[i].pos = '1';
                    }
                    tempNote[i].touch = 'C';
                }

                if (dat.pos[0] == 'D') {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("D")) + dat.pos.slice(dat.pos.indexOf("D") + 1, dat.pos.length);
                    tempNote[i].touch = 'D';
                }

                if (dat.pos[0] == 'E') {
                    tempNote[i].pos = dat.pos.slice(0, dat.pos.indexOf("E")) + dat.pos.slice(dat.pos.indexOf("E") + 1, dat.pos.length);
                    tempNote[i].touch = 'E';
                }

                delete tempNote[i].bpm;
            }

            for (let index = 0; index < tempNote.length; index++) {
                triggered.push(false);
            }
            if (tempNote.length != 0) {
                $("#time").prop("max", Math.max(tempNote[tempNote.length - 1].time + 1000, isNaN(bgm[0].duration) ? 0 : bgm[0].duration * 1000));
            }

            console.log(tempNote);
            return tempNote;
        }

        function render() {
            ctx.canvas.width = $(document).width() / 2;
            ctx.canvas.height = $(document).height();

            ctx.clearRect(0, 0, c.width, c.height);
            ctx.drawImage(noteImages.outline, 0, ctx.canvas.height / 2 - ctx.canvas.width / 2, ctx.canvas.width, ctx.canvas.width);

            if (settings.paused) {
                T = parseFloat($("#time").val());
                bgm[0].currentTime = T / 1000 + settings.offset;
            } else {
                T = Date.now() - startTime;
                $("#time").val(T);
            }


            for (let i = note.length - 1; i >= 0; i--) {
                let n = note[i];
                let t = (T - n.time) / 1000;

                if (t >= 0) {
                    if (!triggered[i]) {
                        sfxs.guide.currentTime = 0;
                        sfxs.guide.play();
                    }
                    triggered[i] = true;
                } else {
                    triggered[i] = false;
                }

                if (!n.touch) {
                    if (t >= -0.5 / (settings.speed)/* && !isNaN(n.pos)*/ && (t <= 0 || t <= n.holdTime)) {
                        if (n.holdTime != null) {
                            hold(n.pos, ((- 0.5 - t * (settings.speed)) * ctx.canvas.width), n.holdTime * ctx.canvas.width * (settings.speed), ctx.canvas.width / 2 * 0.15, n);
                        } else {
                            tap(n.pos, ((- 0.5 - t * (settings.speed)) * ctx.canvas.width), Math.abs(ctx.canvas.width / 2 * 0.15), n);
                        }
                    }
                } else {
                    if (t >= -0.5 / (settings.touchSpeed) && (t <= 0 || t <= n.holdTime)) {
                        if (n.holdTime != null) {
                            touch(n.pos, ((- 0.5 - t * settings.touchSpeed) * ctx.canvas.width), n.touch, n);
                        } else {
                            touch(n.pos, ((- 0.5 - t * settings.touchSpeed) * ctx.canvas.width), n.touch, n);
                        }
                    }
                }
            }
            ctx.beginPath();
            ctx.strokeStyle = "black";
            ctx.font = "10px Arial";
            ctx.fillText("reading :" + triggered.indexOf(false), 10, 100);

            if ($("#loop").prop("checked") && !settings.paused && T >= parseFloat($("#time").prop("max"))) {
                startTime = Date.now();
                T = 0;
                $("#time").val(0);
                if (!isNaN(bgm[0].duration)) {
                    bgm[0].pause();
                    bgm[0].currentTime = settings.offset;
                    bgm[0].play();
                }
            }

            requestAnimationFrame(render);
        }

        function tap(pos, t, r, no) {
            pos = parseInt(pos[0]);
            if (isNaN(pos)) return;

            let ang = (0 - pos) / 8 * 2 * Math.PI + Math.PI / 8;
            let midX = ctx.canvas.width / 2;
            let midY = ctx.canvas.height / 2;
            let ax = Math.sin(ang);
            let ay = Math.cos(ang);
            let d = 0 - midX * settings.disToMid;
            let imgTemp;

            if (no.break) {
                imgTemp = noteImages.break;
            } else {
                let find = note.indexOf(note.find((element) => element.time == no.time));
                if (note[find + 1] != null) {
                    if (note[find] != no || (note[find + 1].time == no.time && note[find + 1])) {
                        imgTemp = noteImages.each;
                    } else {
                        imgTemp = noteImages.tap;
                    }
                } else {
                    imgTemp = noteImages.tap;
                }
            }

            if (d > t) {
                let tr = Math.max(r * settings.noteSize, 0);
                ctx.save();
                ctx.translate(midX + ax * t, midY + ay * t);
                ctx.rotate(ang + Math.PI / 4);

                ctx.drawImage(imgTemp, - tr / 2, - tr / 2, tr, tr);
                if (no.ex) {
                    ctx.drawImage(noteImages.tap_ex, - tr / 2, - tr / 2, tr, tr);
                }

                ctx.restore();
            } else {
                let tr = Math.max(r * (t / d) * settings.noteSize, 0);
                ctx.save();
                ctx.translate(midX + ax * d, midY + ay * d);
                ctx.rotate(ang + Math.PI / 4);

                ctx.drawImage(imgTemp, - tr / 2, - tr / 2, tr, tr);
                if (no.ex) {
                    ctx.drawImage(noteImages.tap_ex, - tr / 2, - tr / 2, tr, tr);
                }

                ctx.restore();
            }
        }

        function hold(pos, t, h, r, no) {
            pos = parseInt(pos[0]);
            if (isNaN(pos)) return;

            let ang = (0 - pos) / 8 * 2 * Math.PI + Math.PI / 8;
            let midX = ctx.canvas.width / 2;
            let midY = ctx.canvas.height / 2;
            let ax = Math.sin(ang);
            let ay = Math.cos(ang);
            let d = 0 - midX * settings.disToMid;
            let th = (1 - settings.noteThickness);
            let imgTemp;

            if (no.break) {
                ctx.strokeStyle = "#FF5000";
                imgTemp = noteImages.hold_break;
            } else {
                let find = note.indexOf(note.find((element) => element.time == no.time));
                if (note[find + 1] != null) {
                    if (note[find] != no || (note[find + 1].time == no.time && note[find + 1])) {
                        ctx.strokeStyle = "#FFDD00";
                        imgTemp = noteImages.hold_each;
                    } else {
                        ctx.strokeStyle = "#FF00A0";
                        imgTemp = noteImages.hold;
                    }
                } else {
                    ctx.strokeStyle = "#FF00A0";
                    imgTemp = noteImages.hold;
                }
            }

            let b = { 'h': imgTemp.height, 'w': imgTemp.width };

            if (d > t) {
                ctx.lineWidth = r * settings.noteThickness;
                ctx.beginPath();
                ctx.moveTo(
                    midX + ax * Math.max(t - r * th, 0 - midX - r * th),
                    midY + ay * Math.max(t - r * th, 0 - midX - r * th));
                ctx.lineTo(
                    midX + ax * Math.max(t - r * th, 0 - midX - r * th) + Math.sin(ang - 60 * Math.PI / 180) * (r * th),
                    midY + ay * Math.max(t - r * th, 0 - midX - r * th) + Math.cos(ang - 60 * Math.PI / 180) * (r * th));
                ctx.lineTo(
                    midX + ax * Math.min(t + h + r * th, d + r * th) + Math.sin(ang - 120 * Math.PI / 180) * (r * th),
                    midY + ay * Math.min(t + h + r * th, d + r * th) + Math.cos(ang - 120 * Math.PI / 180) * (r * th));
                ctx.lineTo(
                    midX + ax * Math.min(t + h + r * th, d + r * th),
                    midY + ay * Math.min(t + h + r * th, d + r * th));
                ctx.lineTo(
                    midX + ax * Math.min(t + h + r * th, d + r * th) + Math.sin(ang + 120 * Math.PI / 180) * (r * th),
                    midY + ay * Math.min(t + h + r * th, d + r * th) + Math.cos(ang + 120 * Math.PI / 180) * (r * th));
                ctx.lineTo(
                    midX + ax * Math.max(t - r * th, 0 - midX - r * th) + Math.sin(ang + 60 * Math.PI / 180) * (r * th),
                    midY + ay * Math.max(t - r * th, 0 - midX - r * th) + Math.cos(ang + 60 * Math.PI / 180) * (r * th));
                ctx.lineTo(
                    midX + ax * Math.max(t - r * th, 0 - midX - r * th),
                    midY + ay * Math.max(t - r * th, 0 - midX - r * th));
                ctx.lineTo(
                    midX + ax * Math.max(t - r * th, 0 - midX - r * th) + Math.sin(ang - 60 * Math.PI / 180) * (r * th),
                    midY + ay * Math.max(t - r * th, 0 - midX - r * th) + Math.cos(ang - 60 * Math.PI / 180) * (r * th));
                ctx.stroke();

            } else {
                ctx.lineWidth = r * settings.noteThickness * t / d;
                ctx.beginPath();
                ctx.beginPath();
                ctx.moveTo(
                    midX + ax * (d + r * th * t / d),
                    midY + ay * (d + r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * t / d) + Math.sin(ang + 120 * Math.PI / 180) * (r * th * t / d),
                    midY + ay * (d + r * th * t / d) + Math.cos(ang + 120 * Math.PI / 180) * (r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * -t / d) + Math.sin(ang + 60 * Math.PI / 180) * (r * th * t / d),
                    midY + ay * (d + r * th * -t / d) + Math.cos(ang + 60 * Math.PI / 180) * (r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * -t / d),
                    midY + ay * (d + r * th * -t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * -t / d) + Math.sin(ang - 60 * Math.PI / 180) * (r * th * t / d),
                    midY + ay * (d + r * th * -t / d) + Math.cos(ang - 60 * Math.PI / 180) * (r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * t / d) + Math.sin(ang - 120 * Math.PI / 180) * (r * th * t / d),
                    midY + ay * (d + r * th * t / d) + Math.cos(ang - 120 * Math.PI / 180) * (r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * t / d),
                    midY + ay * (d + r * th * t / d));
                ctx.lineTo(
                    midX + ax * (d + r * th * t / d) + Math.sin(ang + 120 * Math.PI / 180) * (r * th * t / d),
                    midY + ay * (d + r * th * t / d) + Math.cos(ang + 120 * Math.PI / 180) * (r * th * t / d));
                ctx.stroke();
            }
            if (d > t) {
                let tr = Math.max(r * settings.noteSize, 0);
                ctx.save();
                ctx.translate(midX + ax * t, midY + ay * t);
                ctx.rotate(ang + Math.PI / 4);
                if (no.ex) {
                    ctx.drawImage(noteImages.tap_ex, - tr / 2, - tr / 2, tr, tr);
                }
                ctx.drawImage(imgTemp, - tr / 2, - tr / 2, tr, tr);
                ctx.restore();
            } else {
                let tr = Math.max(r * (t / d) * settings.noteSize, 0);
                ctx.save();
                ctx.translate(midX + ax * d, midY + ay * d);
                ctx.rotate(ang + Math.PI / 4);
                if (no.ex) {
                    ctx.drawImage(noteImages.tap_ex, - tr / 2, - tr / 2, tr, tr);
                }
                ctx.drawImage(imgTemp, - tr / 2, - tr / 2, tr, tr);
                ctx.restore();
            }
        }

        function touch(pos, t, typ, no) {
            let midX = ctx.canvas.width / 2;
            let midY = ctx.canvas.height / 2;
            let rs = { 'A': 2, 'B': 1, 'C': 0, 'D': 2, 'E': 1.5 };
            let ang = (4 - pos) / 8 * 2 * Math.PI + Math.PI / 8;
            if (typ == 'D' || typ == 'E') {
                ang += Math.PI / 8;
            }
            let ax = Math.sin(ang);
            let ay = Math.cos(ang);
            let l = (ctx.canvas.width / 2) * 0.2;
            let ht = (- 0.5 - t) / settings.touchSpeed;

            let find = note.indexOf(note.find((element) => element.time == no.time));
            if (no.holdTime != null) {
                ctx.strokeStyle = "#FF0000";
            } else {
                if (note[find + 1] != null) {
                    if (note[find] != no || (note[find + 1].time == no.time && note[find + 1])) {
                        ctx.strokeStyle = "#FFDD00";
                    } else {
                        ctx.strokeStyle = "#00A2E8";
                    }
                } else {
                    ctx.strokeStyle = "#00A2E8";
                }
            }

            ctx.shadowBlur = 3;
            ctx.shadowColor = "#00000090";
            ctx.lineWidth = l * 0.25;

            ctx.beginPath();
            ctx.strokeRect(midX - l / 2 + ax * (rs[typ] / 4 * ctx.canvas.width), midY - l / 2 + ay * (rs[typ] / 4 * ctx.canvas.width), l, l)
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = "black";
            ctx.font = "10px Arial";
            ctx.fillText(ht, midX - l / 2 + ax * (rs[typ] / 4 * ctx.canvas.width), midY - l / 2 + ay * (rs[typ] / 4 * ctx.canvas.width));
        }
    </script>
    <script>
        let example = `(155){1},
{4}4b/5bs1[16:5]*z1[16:5],,,3/7,
{24}4x/6x,,,,,,B3/E3/B7/E8,,,,,,E6,,,E5,,,E4,,,E7,B7,B8,
{8}E1,E4,E3,E2,C1xh[4:1],,,,
{16}2x/4x,,,,B2/E2/B5/E5,,,,B7/E7,,B2/E3,,B6,B3,B5,B4,
{16}C1,,,E2,B2,,B7/E8,,C1xh[4:1],,,,,,,,
{24}5x/7x,,,5/7,,,B3/E3/B7/E8,,,,,,E6,,,E5,,,E4,,,E7,B7,B8,
{8}E1,E4,E3,E2,C1xh[4:1],,,,
{8}2xh[4:1]/4xh[4:1],,,5xh[4:1]/7xh[4:1],,,1x/8x,,
{4}3bp2[8:3]/6bq7[8:3],,,1/8,
{24}2-5[8:1]/6-1[8:1],,,,,,2b/6b,,,,,,E4,,,E5,,,E6,,,E3,B2,B1,
{8}E1,6x,7xp6[16:5],8,C1f,,,,
{16}3-8[8:1]/7-4[8:1],,,,3b/7b,,,,B2/E3,,B7/E7,,B3,B6,B4,B5,
{16}C1,,,1x,1x>6[4:1],,8,,C1f,,,,,,,,
{24}2-5[8:1]/6-1[8:1],,,1x/5x,,,2b/6b,,,,,,E4,,,E5,,,E6,,,E3,B2,B1,
{8}E1,6x,7xp5[16:5],8,C1f,,,,
{8}1b/8b,,5/6,4b/7b,,3/4,2b/5b,,
{4}1bq3[16:5]/8bp6[16:5],,,4-1[8:1]/5,
{16}8b,,,,4/6,,7,,4/6,,3,,6,5,,5,
{16}7,,,,3/4,,2,,3,4,,4,2,,1/5,,
{16}2b/6b,,,,5/6,,7,,5/6,,4,,6-1[8:1],5,,5,
{8}6b-2[8:1],4,6bV84[4:1],4,6b,3,1b,,
{16}3b/6b,,,,4/7,,6,,2/5,,3,,6,5,,3,
{16}4,,3/5,,6,,5/7,,4,6,4,6,4,6,4,6,
{16}3,5,3,5,2,6,1,7,2,8,4,6,1,7,3,5,
{4}1bpp5[8:3]*qq5[8:3],,,3b/7b,
{16}4/6,,,,6,6,5,5,7h[16:3],,,8h[16:3],,,1<6[8:1],,
{16},,4,,3,3,4,4,2h[16:3],,,1h[16:3],,,8>3[8:1],,
{8},6,7,7,5,5,4,4,
{8}2,2,1pp4[8:3],1,8b,,6,6,
{16}3b/7b,,,,3,3,1,1,2h[16:3],,,3h[16:3],,,4-1[8:1],,
{16},,7,,6,6,8,8,7h[16:3],,,6h[16:3],,,5-8[8:1],,
{16}5x,,2,,3,3,1,1,2h[16:3],,,3h[16:3],,,4,,
{24}4/5,,,3/6,,,2/7,,,8b,7,6,4/5,3,2,6,,,6<1[8:1],,,5,,,
{1}4bs8[4:5]*V62[4:5],
{1},
{8}2b/4b,3h[8:1]/5h[8:1],,3h[8:1]/4h[8:1],,4h[8:1]/6h[8:1],,5h[8:1]/6h[8:1],
{8},3h[8:1]/5h[8:1],,2/4,3,4,5,6,
{8}5b/7b,4h[8:1]/6h[8:1],,5h[8:1]/6h[8:1],,3h[8:1]/5h[8:1],,3h[8:1]/4h[8:1],
{16},,4h[8:1]/6h[8:1],,,,5/7,,6,,4/5,,3,4,3,,
{8}2b/4b,3h[8:1]/5h[8:1],,E4/3h[8:1],,4h[8:1]/6h[8:1],,E6/6h[8:1],
{8},3h[8:1]/5h[8:1],,E4/2,3x,4x,5,6,
{8}5b/7b,4h[8:1]/6h[8:1],,E5/6h[8:1],,3h[8:1]/5h[8:1],,E5/3,
{8}2xh[8:1]/6xh[8:1],,3h[8:1]/7h[8:1],,4x/6x,4/6,3/7,2/6,
{16}1-3[8:1]/5-7[8:1],,,,1b/5b,,,,5/7h[16:3],,,8x,,,2h[16:3]/4,,
{16},1x,,,5/7,,6,,2/4,,3,,4/5,,6,,
{16}3-1[8:1]/7-5[8:1],,,,3b/7b,,,,2h[16:3],,,4,3,,7h[16:3],,
{16},5,6,,2h[16:3],,4,4,2,,3/5,,6,,7,,
{16}4-2[8:1]/8-6[8:1],,1/5,,4b/8b,,,,2,4,,6,5,,7,8,
{16},2,1,,3,4,3,4,2,,1/8,,7,,5/6,,
{8}4xh[4:1]/7xh[4:1],,,2xh[4:1]/5xh[4:1],,,1x/8x,,
{4}2bq3[8:3]/7bp6[8:3],,,4-1[8:7]/5,
{4}5,5,5,C1xh[8:7],
{8}1,1,1,1,1,1,1,1/8,
{32}1,,8,,3,,6,,2,,7,,4,,5,,1,,8,,1,,8,,2,3,4,5,6,7,8,1,
{4}2bq4[16:5]/6bp4[16:5],,,1b-5[8:1]/8b,
{8}1/6-8[8:1],7,1-3[8:1]/6,2,1/7-5[8:1],5-8[8:1],2-4[8:1]/7,3,
{16}2-8[8:1],,7-3[8:1],,2-6[8:1],,7,,2,,7,,7-4[8:1],8,,8,
{8}7b-1[8:1],,3-5[8:1]/7,4,3/8-6[8:1],7,2-6[8:1]/8,1-5[8:1],
{48}2>5[8:1],,,,,,1,,,,,,2,,,,,,7,,,7,,,7,,,,,,2,,,,,,1-5[8:1]/8-4[8:1],,2/7,,3/6,,4/5,,,,,,
{8}1b/8b-6[8:1],,3-1[8:1]/8,2,3/7-5[8:1],6,2-6[8:1]/7,1,
{16}2/7-3[8:1],,8-4[8:1],,7V58[4:1],,8,,7,,2,,2-6[8:1],1,,1,
{8}2b-4[8:1],,2/8-6[8:1],1-5[8:1],8-4[8:1],1-3[8:1],8,1,
{24}8x,,,1x/8x,,,1-5[8:1]/8-4[8:1],2/7,3/6,4/5,,,1b/8b,,,,,,C1f/B3/E3/B6/E7,,,,,,
{4}1b>6[8:3]/8b,,B3/B4,8pp7[8:3],
{24}5,,,,,,,,,,,,2h[4:1],,,8,7,6,5-8[8:1],,,2,,,
{8}3bV14[4:1]/5b,,3/7-5[8:1],8-4[8:1],7-3[8:1],8-2[8:1],7<4[8:1],8,
{16}7b,,,,2/4,,1,,5/7,,6,,4-2[8:1],5,3,,
{16}4b/7b-5[8:1],,8,,1-3[8:1]/7,,8,,1/6-8[8:1],,5,,6-4[8:1],,1,1,
{16}6b<1[8:1],,2,,2/6,,3,,3,4,,7,8-4[8:1],,1-5[8:1]/7,,
{16}8b-6[8:1],,1-3[16:1],,8,,1,,7,2,5,4,8z4[16:5],1,6,3,
{4}8b,,3x/5x,2x-5[8:1]/6x-1[8:1],
{48}2b/6b,,,,,,,,,,,,4xh[4:5]/8b,,,,,,,,,,,,,,,,,,,,,,,,B3,E4,,,,,,,,,,,
(160){48},,,,,,,,,,,,B6,E6,,,,,,,,,,,,,,,,,,,,,,,3x-8[0.375##0.18181818181818699]/7x-4[0.375##0.18181818181818699],,,,,,,,,,,,
(165){48}3b/7b,,,,,,,,,,,,1b/5xh[1:1],,,,,,,,,,,,,,,,,,,,,,,,B6,E6,,,,,,,,,,,
(170){4},4>5[8:3],C1f/B4/B5,,
(175){8}3b/8b,7,6,2/5,3,4,5/7,6,
(180){8}1b/5b,2,3,4/7,6,5,2/4,2/4,
{32}1b,,5,,1,,5,,1,,5,,1,,5,,1,,5,,1,,5,,2,3,4,5,6,7,8,1,
{4}2bpp1[16:5]/6bpp5[16:5],,,3b/7b,
{16}1x/5x,,1h[4:1],,5,6,7,8,2x,,2h[4:1],,6,7,8,1,
{16}3x,,3h[4:1],,7,8,1,2,4xq5[4:1],,4,,C1,,,,
{16}8x,,8h[4:1],,4,3,2,1,7x,,7h[4:1],,3,2,1,8,
{16}6x,,6h[4:1],,2,1,8,7,5xp4[4:1],,5,,C1,,,,
{16}1x,,1h[4:1],,5,6,7,8,2x,,2h[4:1],,6,7,8,1,
{16}3x,,3h[4:1],,7,8,1,2,4x,,4,,3/5,,2/6,,
{16}1,8,1,8,2b/7b,,3,4,2b/5x,,6,5,4x/7b,,1pp4[8:3]/8qq5[8:3],2/7,
{4}3x/6x,,,1b/8b-4[8:1],
{8}2/8-6[8:1],2,3/8-4[8:1],3,2/8-6[8:1],2,1/8-4[8:1],1,
{8}2/8-6[8:1],2,3/8-2[8:1],3,4/8-4[8:1],4-6[8:1],8,1,
{8},2,1-5[8:1]/6,6,1-3[8:1]/7,7,1-5[8:1]/6,6-8[8:1],
{16}1x,,6x,,4x,,8x,,5,7,5,7,4b/8b-4[8:1],,,,
{16}2/8-6[8:1],,2,,3/8-4[8:1],,3,,2/8-6[8:1],,2,,1/8-4[8:1],,1x,2x,
{8}3x/8-6[8:1],3x,2/8-4[8:1],2,3-1[8:1]/8-6[8:1],3,3b/8b,,
{8}1x-5[8:1],8-4[8:1],1-3[8:1],8-6[8:1],1-5[8:1],8,1,7,
{32}7,,8,,7,,8,,7b,6,5,4,,,,,1h[32:3]/2b,3,4,5,,,,,7/8,6,5,4,3,2,1,8,
{1}3bpp8[8:13]/7bqq2[8:13],
{1},
{1},
{1},
`;
    </script>
</head>
<style>
    body {
        margin: 0;
        padding: 0;
    }

    #editor {
        position: absolute;
        left: 50%;
        width: 50%;
        height: 100vh;
        line-height: 20px;
        border: 2px solid #000;
    }

    #render {
        position: absolute;
        left: 0;
        width: 50%;
        height: 100vh;
    }

    .bruh {
        position: absolute;
        display: flex;
        top: 0;
        left: 0;
        width: 50%;
        height: auto;
        background-color: #000;
        color: #fff;
        text-align: center;
        flex-direction: column;
        align-items: flex-start;
    }

    .bruh div {
        width: 100%;
    }

    .time-line {
        position: absolute;
        display: flex;
        left: 0;
        bottom: 0;
        width: 50%;
        height: auto;
        background-color: #000;
        color: #fff;
        text-align: center;
        flex-direction: column;
        align-items: flex-start;
    }

    .time-line>* {
        width: 100%;
    }

    .a1 {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        overflow-x: scroll;
    }

    #offset {
        width: 50px;
    }

    #music {
        width: 100px;
    }

    #bgm-time {
        width: 100px;
        font-family: monospace;
    }

    .imgs {
        display: none;
    }
</style>

<body>
    <canvas id="render"></canvas>
    <textarea id="editor">
    </textarea>
    <audio id="audio"></audio>
    <audio id="sfx-guide" src="answer.wav"></audio>
    <div class="bruh">
        <div class="a1">
            <div>
                速度
                <input type="range" id="speed" value="1" min="0.025" max="10" step="0.025">
            </div>
            <div>
                音樂偏移
                <input type="number" id="offset" value="0">
            </div>
        </div>

    </div>
    <div class="time-line">
        <div class="a1">
            <div><input type="checkbox" id="viewMode">暫停</div>
            <div><input type="checkbox" id="loop">循環</div>
            <div id="bgm-time">0:00/0:00</div>
            <div><input type="file" id="music" accept="audio/*">背景音</div>
        </div>
        <input type="range" id="time" value="0" min="0" max="8" step="10" disabled>
    </div>
    <div class="imgs">
        <img src="Skin/outline.png" alt="outline" id="outline">
        <img src="Skin/tap.png" alt="tap" id="tap">
        <img src="Skin/tap_break.png" alt="break" id="break">
        <img src="Skin/tap_each.png" alt="each" id="each">
        <img src="Skin/hold.png" alt="hold" id="hold">
        <img src="Skin/hold_break.png" alt="hold_break" id="hold_break">
        <img src="Skin/hold_each.png" alt="hold_each" id="hold_each">
        <img src="Skin/touch.png" alt="touch" id="touch">
        <img src="Skin/touch_each.png" alt="touch_each" id="touch_each">
        <img src="Skin/tap_ex.png" alt="tap_ex" id="tap_ex">
    </div>
</body>

</html>